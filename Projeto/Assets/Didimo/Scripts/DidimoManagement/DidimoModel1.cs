using Didimo.Networking.DataObjects;
using System.Collections.Generic;
using System.IO;
using UnityEditor;
using UnityEngine;
using Didimo.Utils;
using Unity.Collections;

namespace Didimo.DidimoManagement
{
    /// <summary>
    /// The DidimoModel class, which we will create after parsing the model json that is generated by our pipeline. <see cref="DidimoModelFactory.CreateDidimoModel(Networking.DataObjects.DidimoModelDataObject)"/>
    /// This class is then used to create the didimo model, with skin weights, materials, etc.
    /// </summary>
    public class DidimoModel1 : DidimoModel<DidimoModelDataObject1>
    {
        public DidimoModel1(DidimoModelDataObject1 dataObject) : base(dataObject)
        {
        }

        protected override void CreateHierarchy(bool updateOnly)
        {
            if (!updateOnly)
            {
                GameObject geometryRoot = new GameObject("Geometry");
                geometryRoot.transform.SetParent(transform, false);

                foreach (DidimoModelDataObject1.Mesh1 mesh in dataObject.meshes)
                {
                    GameObject go = new GameObject(mesh.name);
                    go.transform.SetParent(geometryRoot.transform, false);
                }
            }

            Transform[] boneTransforms = new Transform[dataObject.bones.Length];
            for (int i = 0; i < dataObject.bones.Length; i++)
            {
                if (updateOnly)
                {
                    boneTransforms[i] = transform.FindRecursive(dataObject.bones[i].name);
                }
                else
                {
                    boneTransforms[i] = new GameObject(dataObject.bones[i].name).transform;
                }
            }

            for (int i = 0; i < dataObject.bones.Length; i++)
            {
                //If we are replacing the skeleton, create the bone hierarchy
                if (!updateOnly)
                {
                    int parentIndex = dataObject.bones[i].parentIndex;
                    if (parentIndex == -1)
                    {
                        boneTransforms[i].parent = transform;
                    }
                    else
                    {
                        boneTransforms[i].parent = boneTransforms[parentIndex];
                    }
                }
                SetTransformValues(dataObject.bones[i], boneTransforms[i]);
            }
        }


        Texture2D CombineAlbedoWithAlpha(Texture2D albedo, Texture2D alpha)
        {
            Debug.Assert(albedo.width == alpha.width && albedo.height == alpha.height);

            // We only want linear space for normal maps, and we won't be combining alpha with the normal maps
            Texture2D tex = new Texture2D(albedo.width, albedo.height, TextureFormat.ARGB32, true, false);

            Color[] fillPixels = albedo.GetPixels();
            Color[] alphaPixels = alpha.GetPixels();

            for (int i = 0; i < fillPixels.Length; i++)
            {
                fillPixels[i].a = alphaPixels[i].r;
            }

            tex.SetPixels(fillPixels);

            tex.Apply();

            return tex;
        }

        public override void SetBoneWeights()
        {
            foreach (DidimoModelDataObject1.Mesh1 meshDO in dataObject.meshes)
            {
                List<BoneWeight> boneWeights = new List<BoneWeight>();

                if (meshDO.skinIndices == null || meshDO.influencesPerVertex == 0)
                {
                    Debug.LogWarning("Bone influences per vertex was 0, for mesh " + meshDO.name);
                    continue;
                }

                for (int i = 0; i < meshDO.skinIndices.Count / meshDO.influencesPerVertex; i++)
                {
                    int index = i * meshDO.influencesPerVertex;

                    BoneWeight boneWeight = new BoneWeight();
                    boneWeight.boneIndex0 = meshDO.skinIndices[index];
                    boneWeight.weight0 = meshDO.skinWeights[index];

                    if (meshDO.influencesPerVertex > 1)
                    {
                        boneWeight.boneIndex1 = meshDO.skinIndices[index + 1];
                        boneWeight.weight1 = meshDO.skinWeights[index + 1];
                    }
                    if (meshDO.influencesPerVertex > 2)
                    {
                        boneWeight.boneIndex2 = meshDO.skinIndices[index + 2];
                        boneWeight.weight2 = meshDO.skinWeights[index + 2];
                    }
                    if (meshDO.influencesPerVertex > 3)
                    {
                        boneWeight.boneIndex3 = meshDO.skinIndices[index + 3];
                        boneWeight.weight3 = meshDO.skinWeights[index + 3];
                    }
                    boneWeights.Add(boneWeight);
                }

                SkinnedMeshRenderer smr = transform.FindRecursive(meshDO.name).GetComponent<SkinnedMeshRenderer>();
                Mesh mesh = smr.sharedMesh;

                // set BoneWeight1[] array to empty, otherwise we might get an error when calling mesh.boneWeights = boneWeights.ToArray();
                {
                    var bonesPerVertexArray = new NativeArray<byte>(new byte[0], Allocator.Temp);
                    var weightsArray = new NativeArray<BoneWeight1>(new BoneWeight1[0], Allocator.Temp);
                    smr.sharedMesh.SetBoneWeights(bonesPerVertexArray, weightsArray);
                }
                mesh.boneWeights = boneWeights.ToArray();
                smr.localBounds = mesh.bounds;

                Transform[] boneTransforms = new Transform[dataObject.bones.Length];
                for (int i = 0; i < dataObject.bones.Length; i++)
                {
                    boneTransforms[i] = transform.FindRecursive(dataObject.bones[i].name).transform;
                }

                Matrix4x4[] bindPoses = new Matrix4x4[boneTransforms.Length];
                for (int i = 0; i < boneTransforms.Length; i++)
                {
                    bindPoses[i] = boneTransforms[i].worldToLocalMatrix * smr.transform.localToWorldMatrix;
                }

                mesh.bindposes = bindPoses;
                smr.bones = boneTransforms;
            }
        }

        protected override void SetConstraints()
        {
            // No constraints for this version
        }

        public override bool MeshHasSkinning(string meshName)
        {
            foreach (DidimoModelDataObject1.Mesh1 mesh in dataObject.meshes)
            {
                if (mesh.name == meshName)
                {
                    return mesh.skinIndices != null && mesh.skinIndices.Count > 0;
                }
            }

            Debug.LogError("Failed to find mesh " + meshName);
            return false;
        }


        protected override void SetMaterials()
        {
            // First, load the textures (once), and store them in a map
            // A texture may be shared by multiple textures, and we don't want to load the same texture multiple times
            Dictionary<string, Texture2D> textures = new Dictionary<string, Texture2D>();
            foreach (DidimoModelDataObject1.Mesh1 meshDO in dataObject.meshes)
            {
                if (meshDO.textures != null)
                {
                    foreach (DidimoModelDataObject1.Texture1 textureDO in meshDO.textures)
                    {
                        if (!textures.ContainsKey(textureDO.textureName))
                        {
                            Texture2D texture = null;
                            if (textureDO.textureType == "normal")
                            {
                                texture = new Texture2D(2, 2, TextureFormat.RGBA32, true, true);
                            }
                            else
                            {
                                texture = new Texture2D(2, 2, TextureFormat.RGBA32, true, false);
                            }
                            texture.LoadImage(File.ReadAllBytes(Path.Combine(modelSourcePath, textureDO.textureName)));
                            if (!string.IsNullOrEmpty(textureDO.textureAlpha))
                            {
                                Texture2D alpha = new Texture2D(2, 2);
                                alpha.LoadImage(File.ReadAllBytes(Path.Combine(modelSourcePath, textureDO.textureAlpha)));

                                Texture2D combined = CombineAlbedoWithAlpha(texture, alpha);
                                texture = combined;
                            }
                            textures[textureDO.textureName] = texture;
                        }
                    }
                }
            }

            foreach (DidimoModelDataObject1.Mesh1 meshDO in dataObject.meshes)
            {
                Renderer renderer = transform.FindRecursive(meshDO.name).GetComponent<Renderer>();

                string materialAssetPathTemplate = "DidimoImporter/1.6/" + meshDO.name;
                Material materialTemplate = Resources.Load<Material>(materialAssetPathTemplate);

                if (materialTemplate == null)
                {
                    Debug.LogError("Material not found " + materialAssetPathTemplate);
                    continue;
                }

                Material unityMaterial = new Material(materialTemplate);

                if (meshDO.textures != null)
                {
                    foreach (DidimoModelDataObject1.Texture1 textureDO in meshDO.textures)
                    {
                        SetMaterialTextureProperty(textureDO.textureName, unityMaterial, textures[textureDO.textureName]);
                    }
                }
                renderer.material = unityMaterial;
            }
        }

        protected void SetMaterialTextureProperty(string textureName, Material material, Texture2D texture)
        {
            //Head material: colorSampler ; specSampler ; normalSampler
            if (textureName.Equals("model_retopology.jpg"))
            {
                //Debug.Log("Applying colorSampler on head");
                material.SetTexture("colorSampler", texture);
            }
            else if (textureName.Equals("model_retopology_normalmap.jpg"))
            {
                //Debug.Log("Applying normalSampler on head");
                material.SetTexture("normalSampler", texture);
            }
            else if (textureName.Equals("baseFace_Spec_pub_1001.jpg"))
            {
                //Debug.Log("Applying specSampler on head");
                material.SetTexture("specSampler", texture);
            }
            //eye lashes material: colorSampler
            else
            if (textureName.Equals("coloured_lashes.png"))
            {
                //Debug.Log("Applying colorSampler on eye lashes");
                material.SetTexture("mainMap", texture);
            }
            //eye cornea material: colorSampler
            else
            if (textureName.Equals("coloured_eyes.jpg"))
            {
                //Debug.Log("Applying colorSampler on eye cornea");
                material.SetTexture("colorSampler", texture);
            }
            //eye cornea material: colorSampler
            else
            if (textureName.Equals("coloured_eyes.jpg"))
            {
                //Debug.Log("Applying colorSampler on eye cornea");
                material.SetTexture("colorSampler", texture);
            }
            //unmapped...
            //else Debug.LogWarning("unmapped texture " + textureDO.textureName + " on mesh "+ modelMesh.name);
        }


#if UNITY_EDITOR

        protected override void ImportTextures()
        {
            // Don't load the same texture twice
            HashSet<string> textureNames = new HashSet<string>();

            foreach (DidimoModelDataObject1.Mesh1 mesh in dataObject.meshes)
            {
                if (mesh.textures != null)
                {
                    foreach (DidimoModelDataObject1.Texture1 textureDO in mesh.textures)
                    {
                        if (!textureNames.Contains(textureDO.textureName))
                        {
                            byte[] textureBytes = File.ReadAllBytes(Path.Combine(modelSourcePath, textureDO.textureName));

                            if (!string.IsNullOrEmpty(textureDO.textureAlpha))
                            {
                                Texture2D texture = new Texture2D(2, 2);
                                texture.LoadImage(textureBytes);
                                Texture2D alpha = new Texture2D(2, 2);
                                byte[] alphaBytes = File.ReadAllBytes(Path.Combine(modelSourcePath, textureDO.textureAlpha));
                                alpha.LoadImage(textureBytes);

                                Texture2D combined = CombineAlbedoWithAlpha(texture, alpha);
                                // Always encode to PNG.
                                textureBytes = combined.EncodeToPNG();
                            }

                            string textureDestinationPath = Path.Combine(modelTargetPath, textureDO.textureName);
                            File.WriteAllBytes(textureDestinationPath, textureBytes);
                            AssetDatabase.ImportAsset(textureDestinationPath);
                            TextureImporter textureImporter = AssetImporter.GetAtPath(textureDestinationPath) as TextureImporter;

                            if (textureDO.textureType == "normal")
                            {
                                textureImporter.sRGBTexture = false;
                            }
                            else
                            {
                                textureImporter.sRGBTexture = true;
                            }

                            if (textureDO.textureName.EndsWith(".png"))
                            {
                                textureImporter.alphaIsTransparency = true;
                            }
                            textureNames.Add(textureDO.textureName);
                        }
                    }
                }
            }
        }


        protected override void ImportMaterials()
        {
            for (int meshId = 0; meshId < dataObject.meshes.Length; meshId++)
            {
                DidimoModelDataObject1.Mesh1 meshDO = (DidimoModelDataObject1.Mesh1)dataObject.meshes[meshId];

                Renderer renderer = transform.FindRecursive(meshDO.name).GetComponent<Renderer>();
                string materialAssetPathTemplate = "DidimoImporter/1.6/" + meshDO.name;
                Material materialTemplate = Resources.Load<Material>(materialAssetPathTemplate);

                if (materialTemplate == null)
                {
                    Debug.LogError("Material not found " + materialAssetPathTemplate);
                    continue;
                }

                string materialAssetPath = Path.Combine(modelTargetPath, meshDO.name + ".mat");
                Material unityMaterial = new Material(materialTemplate);
                AssetDatabase.CreateAsset(unityMaterial, materialAssetPath);

                if (meshDO.textures != null)
                {
                    foreach (DidimoModelDataObject1.Texture1 textureDO in meshDO.textures)
                    {
                        Texture2D texture = AssetDatabase.LoadAssetAtPath<Texture2D>(Path.Combine(modelTargetPath, textureDO.textureName));
                        SetMaterialTextureProperty(textureDO.textureName, unityMaterial, texture);
                    }
                }

                renderer.material = unityMaterial;
            }
        }
#endif
    }
}
