using Didimo.Networking.DataObjects;
using Didimo.Networking.Header;
using Didimo.Utils.Coroutines;
using UnityEngine;
using UnityEngine.Networking;

namespace Didimo.Networking
{
    /// <summary>
    /// A custom yield instruction that will run a WWWCachedRequest.
    /// When the response has a "text/html" content type, the response is parsed into <see cref="BaseResponseDataObject"/>. The <see cref="Error"/> property will have the error generated by the UnityWebRequest request (internal server error, etc), or in case of a "NOK" (<see cref="BaseResponseDataObject.IsSuccess"/>), will be the same as <see cref="BaseResponseDataObject.msg"/>.
    /// </summary>
    public class WWWResponseRequest : CustomYieldInstruction
    {
        protected System.Action<UnityWebRequest> doneDelegate;
        protected WWWCachedRequest request;

        private bool shouldLogResponses = false;

        bool ShouldCache(UnityWebRequest webRequest)
        {
            bool shouldDeserialize = request.Error == null && ShouldDeserializeToBaseObject(webRequest);
            if (!shouldDeserialize)
            {
                return request.Error == null;
            }

            BaseResponseDataObject response = BaseResponseDataObject.LoadFromJson<BaseResponseDataObject>(webRequest.downloadHandler.text);
            return response.IsSuccess;
        }

        /// <summary>
        /// Create a request. If the response has a "text/html" content type, the response is parsed into a <see cref="BaseResponseDataObject"/> object.
        /// </summary>
        /// <param name="yieldable">The coroutine manager.</param>
        /// <param name="requestHeader">The request header manager.</param>
        /// <param name="path">The request path.</param>
        /// <param name="form">The form to submit.</param>
        /// <param name="cached">Should this request be cached?</param>
        /// <param name="doneDelegate">Delegate to be called when the request finishes.</param>
        /// <param name="hasAuthentication">Should this request send authentication headers? By default you should ignore this argument.</param>
        /// <param name="autoSaveCache">It true, the request will be saved automatically to cache once completed. Otherwise, the user must call SaveToCache manually.</param>
        public WWWResponseRequest(CoroutineManager yieldable,
            IRequestHeader requestHeader,
            string path,
            WWWForm form,
            bool cached = false,
            System.Action<UnityWebRequest> doneDelegate = null,
            bool hasAuthentication = true,
            bool autoSaveCache = true)
        {
            this.doneDelegate = doneDelegate;
            System.Func<UnityWebRequest, bool> shouldCache = null;
            if (cached)
            {
                shouldCache = ShouldCache;
            }
            request = new WWWCachedRequest(yieldable, requestHeader, path, form, cached, OnRequestDone, null, null, hasAuthentication, shouldCache, autoSaveCache);
        }

        /// <summary>
        /// Create a request. If the response has a "text/html" content type, the response is parsed into a <see cref="BaseResponseDataObject"/> object.
        /// </summary>
        /// <param name="yieldable">The coroutine manager.</param>
        /// <param name="requestHeader">The request header manager.</param>
        /// <param name="path">The request path.</param>
        /// <param name="cached">Should this request be cached?</param>
        /// <param name="doneDelegate">Delegate to be called when the request finishes.</param>
        /// <param name="hasAuthentication">Should this request send authentication headers? By default you should ignore this argument.</param>
        /// <param name="autoSaveCache">It true, the request will be saved automatically to cache once completed. Otherwise, the user must call SaveToCache manually.</param>
        /// <param name="downloadHandler">The download handler for the request.</param>
        public WWWResponseRequest(CoroutineManager yieldable,
            IRequestHeader requestHeader,
            string path,
            bool cached = false,
            System.Action<UnityWebRequest> doneDelegate = null,
            bool hasAuthentication = true,
            bool autoSaveCache = true,
            DownloadHandler downloadHandler = null)
        {
            this.doneDelegate = doneDelegate;
            System.Func<UnityWebRequest, bool> shouldCache = null;
            if (cached)
            {
                shouldCache = ShouldCache;
            }
            request = new WWWCachedRequest(yieldable, requestHeader, path, cached, OnRequestDone, downloadHandler, hasAuthentication, shouldCache, autoSaveCache);
        }

        /// <summary>
        /// Create a request. If the response has a "text/html" content type, the response is parsed into a <see cref="BaseResponseDataObject"/> object.
        /// </summary>
        /// <param name="yieldable">The coroutine manager.</param>
        /// <param name="requestHeader">The request header manager.</param>
        /// <param name="path">The request path.</param>
        /// <param name="binaryData">The data to submit.</param>
        /// <param name="cached">Should this request be cached?</param>
        /// <param name="doneDelegate">Delegate to be called when the request finishes.</param>
        /// <param name="hasAuthentication">Should this request send authentication headers? By default you should ignore this argument.</param>
        /// <param name="contentType">The content type of the request.</param>
        /// <param name="autoSaveCache">It true, the request will be saved automatically to cache once completed. Otherwise, the user must call SaveToCache manually.</param>
        /// <param name="uploadHandler">The upload handler for the request.</param>
        /// <param name="downloadHandler">The download handler for the request.</param>
        public WWWResponseRequest(CoroutineManager yieldable,
            IRequestHeader requestHeader,
            string path,
            byte[] binaryData,
            bool cached = false,
            System.Action<UnityWebRequest> doneDelegate = null,
            bool hasAuthentication = true,
            string contentType = null,
            bool autoSaveCache = true,
            UploadHandler uploadHandler = null,
            DownloadHandler downloadHandler = null)
        {
            this.doneDelegate = doneDelegate;
            System.Func<UnityWebRequest, bool> shouldCache = null;
            if (cached)
            {
                shouldCache = ShouldCache;
            }
            request = new WWWCachedRequest(yieldable, requestHeader, path, binaryData, cached, OnRequestDone, uploadHandler, downloadHandler, hasAuthentication, shouldCache, autoSaveCache, contentType);
        }

        public void SaveRequestToCache()
        {
            request.SaveToCache();
        }

        public void DeleteCacheOfRequest()
        {
            request.DeleteCache();
        }

        /// <summary>
        /// The error message. Might be caught by the WWW, or may be returned from the server ("NOK" status).
        /// </summary>
        public string Error { get; private set; }

        public static bool ShouldDeserializeToBaseObject(UnityWebRequest www)
        {
            string contentType = www.GetResponseHeader("CONTENT-TYPE");
            string contentDisposition = www.GetResponseHeader("CONTENT-DISPOSITION");

            return !string.IsNullOrEmpty(contentType) && contentType.Contains("application/json")
                && (string.IsNullOrEmpty(contentDisposition) || !contentDisposition.Contains("attachment"));
        }


        protected void OnRequestDone(UnityWebRequest www)
        {
            if (request.Error != null)
            {
                Error = request.Error;
            }
            else
            {
                if (ShouldDeserializeToBaseObject(www))
                {
                    BaseResponseDataObject response = DataObject.LoadFromJson<BaseResponseDataObject>(www.downloadHandler.text);

                    if (!response.IsSuccess)
                    {
                        if (response.errors != null && response.errors.Count != 0)
                        {
                            Error = response.errors[0];
                        }
                        else
                        {
                            Error = response.msg;
                        }
                    }
                }
            }

            if (shouldLogResponses)
            {
                Debug.Log("-----" + www.url + "\n" + www.downloadHandler.text);
            }

            if (doneDelegate != null)
            {
                doneDelegate(www);
            }
        }

        public override bool keepWaiting
        {
            get { return !request.IsDone; }
        }

        /// <summary>
        /// Deserialize the json response into a <see cref="BaseResponseDataObject"/>.
        /// </summary>
        /// <typeparam name="TResponse">The type of the object we want to deserialize.</typeparam>
        /// <returns>The deserialized object.</returns>
        public TResponse GetResponseJson<TResponse>() where TResponse : BaseResponseDataObject
        {
            return DataObject.LoadFromJson<TResponse>(request.GetText());
        }

        /// <summary>
        /// Get the response of this request as Texture2D.
        /// </summary>
        /// <returns>The response Texture2D.</returns>
        public Texture2D GetResponseTexture()
        {
            return request.GetTexture();
        }

        /// <summary>
        /// Get the response of this request as a byte array.
        /// </summary>
        /// <returns>The response byte array.</returns>
        public byte[] GetResponseBytes()
        {
            return request.GetBytes();
        }

        /// <summary>
        /// Get the response of this request as a string.
        /// </summary>
        /// <returns>Tge response string.</returns>
        public string GetResponseText()
        {
            return request.GetText();
        }

        /// <summary>
        /// Get the location of the cache file for this request. Returns null if the file wasn't cached or for any other reason doesn't exist.
        /// </summary>
        public string CachedFilePath
        {
            get
            {
                return request.CachedFilePath;
            }
        }
    }
}